# 熟悉OC #

## 了解OC起源 ##

OC语言由Smalltalk演化而来，后者是消息型语言的鼻祖。

OC的重要工作都由运行期组件而非编译器来完成。OC面向对象特性所需的全部数据结构及函数都在运行期组件里面。

OC是C的超集。

OC对象所占内存总是分配在堆空间中，而绝不会分配在栈上。不能在栈中分配OC对象。

## 在类的头文件中尽量少引入其他头文件 ##

使用@class来做前向声明，而不引入头文件。

继承和使用协议必须引入头文件。

## 多用字面量语法，少用与之等价的方法 ##

字面数值
	
	NSNumber *number = @1;

字面量数组

	NSArray *arr = @[@"cat", @"dog", @"mouse"]; 

数组中的元素不能为nil，否则会抛出异常。

取下标

	arr[1];

字面量字典

	NSDictionary *data = @{@"key1" : @"val1", @"key2" : @"val2"};

字典中的对象和键必须都是OC对象。也可以取下标，也不允许出现nil。

字面量语法创建出的字符串、数组、字典对象都是不可变的。若想要可变版本，则需复制一份：

	NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];

## 多用类型常量，少用#define预处理指令 ##

不公开常量定义：

	static const NSTimeInterval kAnimation = 0.3;

应该将此定义放在实现文件中，static意味着该变量仅在定义此变量的编译单元中可见。

公开常量定义：

	extern NSString *const EOCStringConstant;

	NSString *const EOCStringConstant = @"value";

在头文件中声明，在实现文件中定义，以类名为命名前缀。

## 用枚举表示状态、选项、状态码 ##

枚举只是一种常量命名方式。

C++11可以指定枚举的存储类型。

# 对象、消息、运行期 #

## 理解属性这一概念 ##

编译器会在属性名前加下划线，来作为实例变量的名字。也可以在实现代码中使用@synthesize来指定实例变量。

属性的四种特性：

1. 原子性
2. 读写权限
3. 内存管理：assign、strong、weak、copy
4. 方法名

## 在对象内部尽量直接访问实例变量 ##

读取实例变量的时候采用直接访问的形式，设置实例变量的时候通过属性来做。

在初始化方法中应该直接访问实例变量，防止子类可能会重写设置方法。

## 理解对象等同性这一概念 ##

== 比较的是指针本身，而不是其所指的对象。应该使用NSObject中声明的isEqual来判断两个对象的等同性。

NSString 实现了自己独有的判断方法 isEqualToString。

NSObject的isEqual方法的默认实现是：当且仅当其指针值完全相等时，两个对象才相等。

如果isEqual方法判定两个对象相等，那么其hash方法必须返回同一个值，若两个对象的hash方法返回同一个值，那么isEqual方法未必相等。

## 以类族模式隐藏实现细节 ##

通过类族模式可以灵活的创建多个子类，将它们的实现细节隐藏在抽象基类后面。

OC没法指明某个基类是抽象的。

系统框架中的大部分collection类都是类族。

## 在既有类中使用关联对象存放自定义数据 ##

objc_setAssociatedObject、objc_getAssociatedObject、objc_removeAssociatedObject。

## 理解objc_msgSend的作用 ##

函数调用的核心函数。

## 理解消息转发机制 ##

## 理解类对象的用意 ##

# 接口与API设计 #

## 用前缀避免命名空间冲突 ##

实现文件中的纯C函数也会成为顶级符号。

## 提供全能初始化方法 ##

在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。

## 实现description方法 ##

可借助NSDictionary来实现description。

## 尽量使用不可变对象 ##

把可变对象放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构。

尽量把对外公布出来的属性设置为只读的。

## 使用清晰而协调的命名方式 ##

方法与变量名使用驼峰式大小写命名法，以小写字母开头，其后每个单词首字母大写。类名首字母要大写，前面通常还有两三个前缀字母。

如果要从其他框架中继承子类，那么务必遵循其命名惯例。比如从UIView类中继承的子类末尾必须是View，如果是自定义委托，则应以Delegate结尾。

## 为私有方法名加前缀 ##

私有方法只在实现中声明。

方法名以p_开头。

不要单用一个下划线做私有方法的前缀，这是预留给苹果公司用的。

## 理解OC错误模型 ##

ARC在默认情况下不是异常安全的，如果抛出异常，那么本应在作用域末尾释放的对象现在都不会自动释放了。

如果想生成异常安全的代码，可以设置-fobjc-arc-exceptions编译器标志。

OC所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无需考虑恢复问题，应用应该此时退出。

对于不那么严重的错误，OC的编程范式为：返回nil/0或者使用NSError。

## 理解NSCopying协议 ##

自定义类支持拷贝操作，就要实现NSCopying协议。

1. NSCopying不可变拷贝
2. NSMutableCopying可变拷贝

	[NSMutableArray copy] --> NSArray
	[NSArray mutableCopy] --> NSMutableCopy

Foundation框架中的所有collection类在默认情况下都执行浅拷贝。

一般NSCopying的实现中执行浅拷贝，若需要深拷贝，则可以单独编写一个deepCopy方法。

# 协议与分类 #

## 通过委托与数据源协议进行对象间通信 ##

委托模式：定义一套接口，某对象若需要接受另一个对象的委托，则需要遵循此接口。

通过OC的协议来实现委托。

委托协议名通常是在相关类名后面加上Delegate一词。

用属性来存放委托对象，并定义为weak，防止循环引用：

	@property (nonatomic, weak) id<Delegate> delegate;

委托中的方法可以是可选的，使用@optional指定。

在调用时先判断这个委托对象能否响应相关选择子：

	if([_delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]){

	}

## 将类的实现代码分散到便于管理的数个分类之中 ##

可以用分类来划分类，避免实现文件过大。

可以创建名为Private的分类，把私有方法都放入其中。

## 勿在分类中声明属性 ##

## 使用class-continuation分类隐藏实现细节 ##

class-continuation分类和普通的分类不同，它必须定义在其类的实现文件里，这是唯一能声明实例变量的分类。

实例变量也可以定义在实现块中。

与其他分类不同，class-continuation分类没有名字。

## 通过协议提供匿名对象 ##

返回的对象设计为遵从此协议的纯id类型。

# 内存管理 #

## 理解引用计数 ##

## 以ARC简化引用计数 ##

ARC在调用这些方法时，并不通过普通的OC消息派发机制，而是直接调用底层C语言版本，以获得更好的性能。

## 在dealloc方法中只释放引用并解除监听 ##

对象在经历其生命周期后，最终会为系统所回收，这时就要执行dealloc方法，当保留计数降为0的时候执行。

dealloc在ARC环境下只需要释放那些非OC对象，如套接字、内存块等。

## 编写异常安全代码时留意内存管理问题 ##

默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。

## 以自动释放池块降低内存峰值 ##

	@autoreleasepool {

	}

把循环内的代码包裹在自动释放池中，那么循环中自动释放的对象就会放在这个池中。

# 块与大中枢派发 #

## 理解块这一概念 ##

块与函数类似，只不过是直接定义在另一个函数里的，和定义它的那个函数共享同一个范围内的东西。

	^{

	}

块其实就是个值，而且自有其相关类型。

	int (^addBlock)(int a, int b) = ^(int a, int b){
		return a + b;
	}

默认情况下，为块所捕获的变量，是不可以在块里修改的，如果要修改需要声明时加上__block修饰符。

如果块定义在OC类的实例方法中，那么除了可以访问类的所有实例变量之外，还可以使用self变量。块总能修改实例变量，无需添加__block。

定义块时，其所占的内存区域是分配在栈中的。也就是只有在它定义的那个范围内有效。要解决这个问题，需要使用copy来从栈复制到堆。

全局块不会捕捉任何状态，运行时也无须有状态来参与。

## 为常用的块类型创建typedef ##

## 用handler块降低代码分散程度 ##

用handler块来代替委托，写出来的代码更为整洁。

建议使用同一个块来处理成功与失败的情况。

## 用块引用其所属对象时不要出现保留环 ##

## 多用派发队列，少用同步锁 ##

全部加锁任务都在GCD中处理，而GCD是在相当深的底层来实现的，于是能做许多优化。